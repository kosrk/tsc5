#include "imports/stdlib.fc";

;; add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;
;; remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;
;; split_ton#068530b3 query_id:uint64 amount:Coins = InternalMsgBody;
;; transfer_notification#701c09a6 query_id:uint64 amount:Coins = InternalMsgBody;

;; storage
;; admin_address: MsgAddressInt
;; users: (HashmapE 256 uint32)
;; total_share optional

(cell, (slice, int)) ~udict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETGETB NULLSWAPIFNOT";

;; TODO: move to receiver
int parse_sender_address (cell in_msg_full) inline {
    var cs = in_msg_full.begin_parse();
    cs~load_uint(4 + 11); ;; flags + addr std op + wc
    return cs.preload_uint(256); ;; sender address
}

(int, cell, int) load_data() inline {
    var ds = get_data().begin_parse();
    ds~load_uint(11);
    ;; cell dic = ds.slice_bits() == 0 ? new_dict() : data; ;; check for empty dict
    int total_share = 0;
    var (addr, dict) = (ds~load_uint(256), ds~load_dict());
    if ds.slice_bits() >= 64 {
        total_share = ds~load_uint(64);
    }
    return (addr, dict, total_share); ;; owner addr and map
}

() save_data(int owner, cell dict, int total_share) impure inline {
    set_data(
            begin_cell()
                    .store_uint(1024,11)
                    .store_uint(owner, 256)
                    .store_dict(dict)
                    .store_uint(total_share, 64)
                    .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

    if (in_msg_body.slice_bits() < 32) { ;; ignore short messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    if (op == 0x368ddef3) { ;; add user
        int sender_address = parse_sender_address(in_msg_full);
        var (owner, dict, total_share) = load_data(); ;; TODO: load owner first and dict after check
        throw_unless(120, sender_address == owner);
        in_msg_body~skip_bits(64 + 11); ;; query_id and addr prefix
        var (user, share) = (in_msg_body~load_uint(256), in_msg_body~load_uint(32));
        total_share += share;
        var (old_share, res) = dict~udict_set_get_builder?(256, user, begin_cell().store_uint(share, 32));
        if res {
            total_share -= old_share~load_uint(32);
        }
        save_data(owner, dict, total_share);
        return();
    }

    if (op == 0x278205c8) { ;; remove user
        int sender_address = parse_sender_address(in_msg_full);
        var (owner, dict, total_share) = load_data(); ;; TODO: load owner first and dict after check
        throw_unless(120, sender_address == owner);
        var (_, user) = (in_msg_body~load_uint(64 + 11), in_msg_body~load_uint(256));
        var (old_share , res) = dict~udict_delete_get?(256, user);
        throw_unless(121, res);
        total_share -= old_share~load_uint(32);
        save_data(owner, dict, total_share);
        return();
    }

    if (op == 0x068530b3) { ;; split ton
        var (_, dict, _) = load_data(); ;; TODO: load owner first and dict after check
        throw_if(122, dict.dict_empty?());
        return();
    }

    if (op == 0x701c09a6) { ;; transfer notification
        var (_, dict, _) = load_data(); ;; TODO: load owner first and dict after check
        throw_if(122, dict.dict_empty?());
        return();
    }
}

;; Get methods

cell get_users() method_id {
    var cs = get_data().begin_parse();
    cs~skip_bits(267);
;;     var dict = cs~load_dict();
;;     if dict.dict_empty?() {
;;        return null();
;;     }
    return cs~load_dict(); ;; TODO: optimize
}

int get_user_share(slice user_address) method_id {
    var cs = get_data().begin_parse();
    cs~skip_bits(267);
    var dict = cs.preload_dict();
    user_address~skip_bits(11);
    var (share, res) = dict.udict_get?(256, user_address~load_uint(256));
    return share.preload_uint(32);
}
